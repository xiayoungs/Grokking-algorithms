常见的大O运行时间

O（log n），也叫对数时间，这样的算法包括二分查找。
O（n），也叫线性时间，这样的算法包括简单查找。
O（n * log n），这样的算法包括快速排序——一种速度较快的排序算法。
O（n^2），这样的算法包括选择排序——一种速度较慢的排序算法。
O（n!），这样的算法包括旅行商问题的解决方案——一种非常慢的算法。

二分查找
假设要在字典中找一个以O打头的单词，你将从中间附近开始。这是一个查找问题，都可使用同一种算法来解决问题，这种算法就是二分算法。

def binary_search(list,item):
    low = 0						#low和high用于跟踪要在其中查找的列表部分
    high = len(list)-1
    while low <= high:          #只要范围没有缩小到只包含一个元素，
    	mid = (low + high)/2    #就检查中间的元素
    	guess = list[mid]
    	if guess == item:            #找到了元素
    		return mid
    	if guess > item:            #猜的数字大了
    		high = mid - 1
    	else:                       #猜的数字小了
    		low = mid + 1
    return None                 #没有指定的元素
my_list = [1,3,5,7,9]            #测试
    
print (binary_search(my_list,3)) # =>1        #索引从0开始，第二个位置索引为1
print (binary_search(my_list,-1)) # =>None    #在Python中，None表示空，它意味着没有找到指定的元素



选择排序
链表：链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存串在一起。
在链表中，元素并非靠在一起，无法迅速计算出某个元素的内存地址，必须先访问第一个元素的地址才能继续访问第二个元素的地址，以此类推，直到访问到所需要的元素地址。
数组：知道每个元素的地址。需要随机地读取元素时，数组的效率很高，因为可以迅速找到数组的任何元素。
假设计算机存储了很多乐曲。对于每个乐队，都记录了其作品被播放的次数。要将这个列表按播放次数从多到少的顺序排列，从而将喜欢的乐队排序。
一种办法是遍历这个列表，找出作品播放次数最多的乐队，并经该乐队添加到一个新列表中。再次这样做，找出播放次数第二多的乐队。继续这样做，将得到一个有序列表。

快速排序

分而治之
D&C的工作原理：
（1）找出简单的基线条件；
（2）确定如何缩小问题的规模，使其符合基线条件
D&C并非可用于解决问题的算法，而是一种解决问题的思路。

使用D&C，需要将数组分解，直到满足基线条件。快速排序的工作原理：首先，从数组中选择一个元素，这个元素被称为基准值（pivot）。
暂时将第一个元素作为基准值，接下来找出比基准值小的元素以及比基础值大的元素。
这被称为分区（partitioning），现在有：

1、一个由所有小于基准值得数字组成的子数组；
2、基准值；
3、一个由所有大于基准值得数组组成的子树组。

这里只是进行了分区，得到的两个子树组是无序的。
如果对子树组进行排序，对于包含两个元素的数组（左边的子树组）以及空数组（右边的子树组），快速排序知道如何将他们排序，
因此只要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组。

quicksort ([15,10]) + [33] + quicksort([])
>[10,15,33]          #一个有序数组

步骤：
选择基准值。
将数组分成两个子树组：小于基准值的元素和大于基准值的元素。
对这两个子数组进行快速排序。
快速排序的代码实现

 def quicksort(array):
 	if len(array) <2:
 		return array                #基线条件：为空或只包含一个元素的数组是"有序"的
 	else:
 	pivot = array[0]              #递归条件
 	less = [i for i in array[1:] if i <= pivot]              #由所有小于等于基准值的元素组成的子数组
 	greater = [i for i in array[1:] if i >pivot]             #由所有大于基准值的元素组成的子树组
 	return quicksort(less) +[pivot] +quicksort(greater)
 	print (quicksort([10,5,2,3]))
